#!/bin/sh /etc/rc.common
#file: /etc/init.d/nrsyncd
## Based on: https://forum.openwrt.org/t/how-does-rrm-work/32635/68

# shellcheck disable=SC2034  # consumed by /etc/rc.common framework
START=99

NAME=nrsyncd
# shellcheck disable=SC2034  # procd flag used implicitly
USE_PROCD=1
NRSYNCD_INIT_VERSION="1.1.0"
# shellcheck disable=SC2034  # rc.common reads EXTRA_COMMANDS
EXTRA_COMMANDS="mapping mapping_json mapping-json neighbors cache refresh diag metrics timing_check timing-check version status skiplist summary reset_metrics metadata overlay overlay_state"
# shellcheck disable=SC2034  # rc.common reads EXTRA_HELP
EXTRA_HELP="  mapping        Show iface/BSSID/channel/freq/width/center1/SSID\n  mapping_json   JSON array variant of mapping (mapping-json also)\n  neighbors      Dump current neighbor lists\n  cache          Show cache directory summary\n  refresh        Force immediate refresh (SIGUSR1)\n  diag           Probe readiness timings (per iface)\n  metrics        Show metrics counters (if present)\n  summary        Concise metrics summary (ratios, uniques)\n  reset_metrics  Reset metrics/unique remote counters (SIGUSR2)\n  timing_check   Alias of diag (timing-check also accepted)\n  version        Show init script version + git hash (if available)\n  status         Show runtime state + metrics summary\n  skiplist       Show configured skip_iface entries (effective)\n  metadata       Show advertised SSID metadata (parsed)\n  overlay        Show overlay files (ordinal map + tokens)\n  overlay_state  Alias of overlay\n"

# Optional: on OpenWrt this exists; allow tests to source the script without it.
. /lib/functions.sh 2>/dev/null || true
# Rebranded common helpers (legacy name source removed; keep only new file)
. /lib/nrsyncd_common.sh 2>/dev/null || true

CFG_UPDATE_INTERVAL=60
CFG_JITTER_MAX=10
CFG_DEBUG=0
CFG_UMDNS_REFRESH_INTERVAL=30
CFG_UMDNS_SETTLE_DELAY=0
CFG_SKIP_IFACES=""
CFG_ENABLED=1
CFG_QUICK_MAX_MS=2000
CFG_SECOND_PASS_MS=800
CFG_ACTIVITY_OVERLAY=0
CFG_OVERLAY_I_STATIC=""
CFG_SIDECHANNEL_ENABLE=0
CFG_SIDECHANNEL_PORT=32026
CFG_SIDECHANNEL_PROTO="udp"
CFG_SIDECHANNEL_PSK=""
CFG_SIDECHANNEL_BIND=""
CFG_SIDECHANNEL_BCAST_ENABLE=0
CFG_SIDECHANNEL_BCAST_INTERVAL=60
CFG_SIDECHANNEL_BCAST_JITTER=10
CFG_EXTENDED=0

append_skip_iface() {
	val="$1"
	[ -n "$val" ] && CFG_SKIP_IFACES="${CFG_SKIP_IFACES} ${val}"
}

load_nrsyncd_config() {
	CFG_SKIP_IFACES=""
	config_load nrsyncd
	config_get CFG_ENABLED global enabled 1
	config_get CFG_UPDATE_INTERVAL global update_interval 60
	config_get CFG_JITTER_MAX global jitter_max 10
	config_get CFG_DEBUG global debug 0
	config_get CFG_UMDNS_REFRESH_INTERVAL global umdns_refresh_interval 30
	config_get CFG_UMDNS_SETTLE_DELAY global umdns_settle_delay 0
	config_get CFG_QUICK_MAX_MS global quick_max_ms 2000
	config_get CFG_SECOND_PASS_MS global second_pass_ms 800
	config_get CFG_ACTIVITY_OVERLAY global activity_overlay 0
	# Internal publisher removed to simplify core; dynamics use sidechannel if extended.
	config_get CFG_OVERLAY_I_STATIC global overlay_i_static ""
	config_get CFG_EXTENDED global extended 0
	# Optional peer-to-peer sidechannel for richer state exchange (discovery still via mDNS)
	config_get CFG_SIDECHANNEL_ENABLE global sidechannel_enable 0
	config_get CFG_SIDECHANNEL_PORT global sidechannel_port 32026
	config_get CFG_SIDECHANNEL_PROTO global sidechannel_proto udp
	config_get CFG_SIDECHANNEL_PSK global sidechannel_psk ""
	config_get CFG_SIDECHANNEL_BIND global sidechannel_bind ""
	config_get CFG_SIDECHANNEL_BCAST_ENABLE global sidechannel_broadcast_enable 0
	config_get CFG_SIDECHANNEL_BCAST_INTERVAL global sidechannel_broadcast_interval 60
	config_get CFG_SIDECHANNEL_BCAST_JITTER global sidechannel_broadcast_jitter 10

	# Gate advanced / experimental features unless extended=1 explicitly set.
	if [ "$CFG_EXTENDED" != "1" ]; then
		CFG_ACTIVITY_OVERLAY=0
		CFG_SIDECHANNEL_ENABLE=0
		CFG_SIDECHANNEL_BCAST_ENABLE=0
	fi

	# Sanitize numeric bounds for advanced readiness knobs
	case "$CFG_QUICK_MAX_MS" in '' | *[!0-9]*) CFG_QUICK_MAX_MS=2000 ;; esac
	[ "$CFG_QUICK_MAX_MS" -gt 5000 ] && CFG_QUICK_MAX_MS=5000
	case "$CFG_SECOND_PASS_MS" in '' | *[!0-9]*) CFG_SECOND_PASS_MS=800 ;; esac
	[ "$CFG_SECOND_PASS_MS" -gt 1500 ] && CFG_SECOND_PASS_MS=1500

	# List syntax: one 'list skip_iface <iface>' per interface
	config_list_foreach global skip_iface append_skip_iface 2>/dev/null || true

	CFG_SKIP_IFACES=$(normalize_iflist "$CFG_SKIP_IFACES")
	# Accept optional 'hostapd.' prefixes (user convenience); strip them.
	if [ -n "$CFG_SKIP_IFACES" ]; then
		new_list=""
		for x in $CFG_SKIP_IFACES; do
			case "$x" in hostapd.*) x=${x#hostapd.} ;; esac
			new_list="$new_list $x"
		done
		CFG_SKIP_IFACES=$(normalize_iflist "$new_list")
	fi
}

get_wifi_iface_count() { grep -c 'wifi-iface' /etc/config/wireless; }

get_enabled_iface_count() {
	count=0
	total=$(get_wifi_iface_count)
	seq_end=$((total - 1))
	for i in $(seq 0 "$seq_end"); do
		disabled=$(uci -q get "wireless.@wifi-iface[${i}].disabled" 2>/dev/null)
		[ "$disabled" = "1" ] && continue
		count=$((count + 1))
	done
	echo "$count"
}

start_service() {
	[ ! -f /etc/config/wireless ] && logger -t "${NAME}" -p daemon.error "/etc/config/wireless does not exist" && exit 1

	# Initial startup log (version + config summary after load)
	load_nrsyncd_config
	logger -t "${NAME}" -p daemon.info "Starting (init ver=${NRSYNCD_INIT_VERSION})"

	if [ "$CFG_ENABLED" = "0" ]; then
		logger -t "${NAME}" -p daemon.info "Disabled via UCI (nrsyncd.global.enabled=0)"
		exit 0
	fi

	wifi_iface_count=$(get_wifi_iface_count)
	[ "$wifi_iface_count" -eq 0 ] && logger -t "${NAME}" -p daemon.error "No wifi-iface stanzas found in /etc/config/wireless" && exit 1

	enabled_iface_count=$(get_enabled_iface_count)
	[ "$enabled_iface_count" -eq 0 ] && logger -t "${NAME}" -p daemon.error "No enabled wifi-iface stanzas found in /etc/config/wireless" && exit 1

	logger -t "${NAME}" -p daemon.info "Waiting for all wireless interfaces to initialize."
	wait_start=$(date +%s 2>/dev/null)
	[ -z "$wait_start" ] && wait_start=0
	timeout_sec=$((5 * 60))
	while :; do
		current=$(ubus list hostapd.* | wc -l)
		expected=$(get_enabled_iface_count)
		[ "$current" = "$expected" ] && break
		now=$(date +%s 2>/dev/null)
		[ -z "$now" ] && now=$wait_start
		if [ $((now - wait_start)) -ge "$timeout_sec" ]; then
			logger -t "${NAME}" -p daemon.error "Timeout waiting for hostapd objects (got $current / expected $expected). Check wireless config & hostapd logs." && exit 1
		fi
		sleep 3
	done
	logger -t "${NAME}" -p daemon.info "All wireless interfaces are initialized."

	NRSYNCD_UPDATE_INTERVAL=$CFG_UPDATE_INTERVAL
	NRSYNCD_JITTER_MAX=$CFG_JITTER_MAX
	NRSYNCD_DEBUG=$CFG_DEBUG
	NRSYNCD_UMDNS_REFRESH_INTERVAL=$CFG_UMDNS_REFRESH_INTERVAL
	NRSYNCD_UMDNS_SETTLE_DELAY=$CFG_UMDNS_SETTLE_DELAY
	NRSYNCD_ACTIVITY_OVERLAY=$CFG_ACTIVITY_OVERLAY

	# Backward compatibility: export legacy RRM_NR_* names so existing binary builds
	# (still expecting old env names) continue functioning. Can be removed after
	# daemon gains native NRSYNCD_* support.
	RRM_NR_UPDATE_INTERVAL=$NRSYNCD_UPDATE_INTERVAL
	RRM_NR_JITTER_MAX=$NRSYNCD_JITTER_MAX
	RRM_NR_DEBUG=$NRSYNCD_DEBUG
	RRM_NR_UMDNS_REFRESH_INTERVAL=$NRSYNCD_UMDNS_REFRESH_INTERVAL
	RRM_NR_UMDNS_SETTLE_DELAY=$NRSYNCD_UMDNS_SETTLE_DELAY
	RRM_NR_ACTIVITY_OVERLAY=$NRSYNCD_ACTIVITY_OVERLAY
	skip_ifaces=$CFG_SKIP_IFACES

	# Warn if any configured skip_iface entries don't match a current hostapd object
	if [ -n "$skip_ifaces" ]; then
		all_ifaces=$(ubus list hostapd.* 2>/dev/null | sed 's/^hostapd.//')
		unmatched=""
		for s in $skip_ifaces; do
			found=0
			for h in $all_ifaces; do [ "$s" = "$h" ] && found=1 && break; done
			[ $found -eq 0 ] && unmatched="$unmatched $s"
		done
		[ -n "$unmatched" ] && logger -t "${NAME}" -p daemon.warning "Configured skip_iface entries not present: $(echo "$unmatched" | sed 's/^ *//')"
	fi

	# Build argument list safely (no '+' delimiter); accumulate as positional args
	# so SSIDs may contain any characters, including spaces and plus signs.
	set --
	ssid_count=0
	unready_list=""
	cfg_skipped=0
	ordinal_map_pairs=""
	# Use configured (already sanitized) readiness timing values
	QUICK_MAX_MS=$CFG_QUICK_MAX_MS
	SECOND_PASS_MS=$CFG_SECOND_PASS_MS

	# First pass
	for obj in $(ubus list hostapd.*); do
		iface=${obj#hostapd.}
		sk=0
		for s in $skip_ifaces; do [ "$iface" = "$s" ] && sk=1 && break; done
		if [ $sk -eq 1 ]; then
			cfg_skipped=$((cfg_skipped + 1))
			continue
		fi
		json=$(rrm_get_own_quick "$iface") || {
			[ "$CFG_DEBUG" = "1" ] && logger -t "${NAME}" -p daemon.debug "iface $iface not yet ready (deferred)"
			unready_list="$unready_list $iface"
			continue
		}
		val=$(echo "$json" | jsonfilter -e '$.value')
		ssid_count=$((ssid_count + 1))
		set -- "$@" "SSID${ssid_count}=${val}"
		ordinal_map_pairs="$ordinal_map_pairs ${ssid_count}:$iface"
	done

	[ -n "$unready_list" ] && rrm_nr_sleep_ms "$SECOND_PASS_MS"
	final_unready=""
	if [ -n "$unready_list" ]; then
		_saved_IFS=$IFS
		IFS=' '
		for iface in $unready_list; do
			[ -z "$iface" ] && continue
			json=$(ubus call "hostapd.$iface" rrm_nr_get_own 2>/dev/null) || {
				final_unready="$final_unready $iface"
				continue
			}
			val=$(echo "$json" | jsonfilter -e '$.value')
			[ -n "$val" ] || {
				final_unready="$final_unready $iface"
				continue
			}
			ssid_count=$((ssid_count + 1))
			set -- "$@" "SSID${ssid_count}=${val}"
			ordinal_map_pairs="$ordinal_map_pairs ${ssid_count}:$iface"
			[ "$CFG_DEBUG" = "1" ] && logger -t "${NAME}" -p daemon.debug "iface $iface became ready in second pass"
		done
		IFS=$_saved_IFS
	fi

	if [ -n "$final_unready" ]; then
		# Intentional word splitting (final_unready is space-delimited list); suppress SC2086
		# shellcheck disable=SC2086
		_saved_IFS=$IFS
		IFS=' '
		set -- $final_unready
		not_ready_count=$#
		IFS=$_saved_IFS
	else
		not_ready_count=0
	fi
	if [ $cfg_skipped -eq 0 ] && [ $not_ready_count -eq 0 ]; then
		logger -t "${NAME}" -p daemon.info "Assembled $ssid_count SSID entries (no skips)"
	else
		logger -t "${NAME}" -p daemon.info "Assembled $ssid_count SSID entries (config-skipped $cfg_skipped, not-ready $not_ready_count)"
	fi

	# Log effective skip list (only if non-empty) for operator clarity
	[ -n "$skip_ifaces" ] && logger -t "${NAME}" -p daemon.info "Skip list: $skip_ifaces"

	# Debug: show assembled SSID argument list (count + first few)
	if [ "$CFG_DEBUG" = "1" ]; then
		_show=""
		c=0
		for a in "$@"; do
			c=$((c + 1))
			[ $c -le 5 ] && _show="${_show}${_show:+ }$a"
		done
		[ $c -gt 5 ] && _show="${_show} ... (total $c)" || _show="${_show} (total $c)"
		logger -t "${NAME}" -p daemon.debug "Prepared SSID args: ${_show}"
	fi

	# ----- Extensible mDNS TXT metadata (appended AFTER all SSIDn= entries) -----
	# Maintain invariant: all SSIDn= positional TXT entries first & stable numbering.
	# Added keys:
	#   v=1          protocol/meta version (increment if semantics of additional keys change)
	#   c=<int>      count of SSIDn= entries (integrity aid)
	#   h=<8hex>     short hash (first 8 hex chars of md5 over concatenated SSIDn= strings)
	# Future keys may be appended; consumers must ignore unknown tokens.
	ssid_meta_count=$#
	hash_input=""
	for _arg in "$@"; do case "$_arg" in SSID[0-9]*=*) hash_input="${hash_input}${_arg}|" ;; esac done
	if command -v md5sum >/dev/null 2>&1; then
		ssid_meta_hash=$(printf '%s' "$hash_input" | md5sum 2>/dev/null | awk '{print $1}' | cut -c1-8)
	else
		ssid_meta_hash=na
	fi
	# Protocol version: bump to 2 when activity overlay flag enabled so peers can
	# detect possible additional TXT keys (a=/i=). Placeholder tokens are appended
	# after base metadata to preserve invariant ordering (all SSIDn=, then v/c/h, then extras).
	proto_ver=1
	if [ "$CFG_ACTIVITY_OVERLAY" = "1" ]; then
		proto_ver=2
	fi
	set -- "$@" v="$proto_ver" c="$ssid_meta_count" h="$ssid_meta_hash"
	if [ "$CFG_ACTIVITY_OVERLAY" = "1" ]; then
		# Placeholder overlay tokens (no dynamic classification yet). Using <none>
		# allows future replacement without ambiguity while signaling capability.
		set -- "$@" a="<none>" i="<none>"
	fi
	# Sidechannel advertisement (protocol:port). Only advertise when enabled.
	if [ "$CFG_SIDECHANNEL_ENABLE" = "1" ]; then
		_sc_proto="${CFG_SIDECHANNEL_PROTO:-udp}"
		_sc_port="${CFG_SIDECHANNEL_PORT:-32026}"
		# Token name: sc=proto:port (no secrets). Appends after v/c/h and overlay extras.
		set -- "$@" sc="${_sc_proto}:${_sc_port}"
	fi

	# ---------------------------------------------------------------------------
	# Defensive TXT token cap handling:
	# BusyBox umdns appears to silently drop TXT records beyond an internal cap
	# (empirically observed at 8). With overlay placeholders enabled we may have:
	#   SSID1..N (>=1) + v= + c= + h= + a=<none> + i=<none> + sc=  => 3 + 5 = 8 (OK) or
	#   4 SSIDs -> 4 + 5 = 9 (overflow) etc.
	# To preserve discoverability of the sidechannel (sc=), we trim lowest-value
	# placeholder overlay tokens first when we exceed 8 tokens total. Priority:
	#   1) Keep all SSIDn= (never removed)
	#   2) Keep v= c= h=
	#   3) Keep sc= (if sidechannel enabled)
	#   4) Keep a= then i= (drop i=<none> first, then a=<none> if still over)
	# If real (non-placeholder) overlay tokens are present in future they should
	# not be trimmed; current implementation only uses <none> placeholders.
	TXT_CAP=8
	# Count total tokens
	_tok_count=0
	for _t in "$@"; do
		_tok_count=$((_tok_count + 1))
	done
	if [ $_tok_count -gt $TXT_CAP ]; then
		_pruned=0
		newlist=""
		# Helper to rebuild list while skipping one occurrence
		prune_once() {
			_skip_tok="$1"; _done=0; newlist=""; for _t in "$@"; do :; done
		}
		# First attempt: drop i=<none>
		if printf '%s\n' "$@" | grep -q '^i=<none>$'; then
			for _t in "$@"; do
				if [ "$_t" = 'i=<none>' ] && [ $_pruned -eq 0 ]; then _pruned=1; continue; fi
				set -- "$@"
			newlist="${newlist}${newlist:+ }$_t"
			done
			# Re-evaluate list into positional parameters
			# shellcheck disable=SC2086
			set -- $newlist
		fi
		# Recount; if still over cap, drop a=<none>
		_tok_count=0; for _t in "$@"; do _tok_count=$((_tok_count + 1)); done
		if [ $_tok_count -gt $TXT_CAP ] && printf '%s\n' "$@" | grep -q '^a=<none>$'; then
			_pruned2=0; newlist=""
			for _t in "$@"; do
				if [ "$_t" = 'a=<none>' ] && [ $_pruned2 -eq 0 ]; then _pruned2=1; continue; fi
				newlist="${newlist}${newlist:+ }$_t"
			done
			# shellcheck disable=SC2086
			set -- $newlist
		fi
		# Final recount; if still over cap (rare: very high SSID count) drop sc=
		_tok_count=0; for _t in "$@"; do _tok_count=$((_tok_count + 1)); done
		if [ $_tok_count -gt $TXT_CAP ] && printf '%s\n' "$@" | grep -q '^sc='; then
			_pruned3=0; newlist=""
			for _t in "$@"; do
				case "$_t" in sc=*) if [ $_pruned3 -eq 0 ]; then _pruned3=1; continue; fi;; esac
				newlist="${newlist}${newlist:+ }$_t"
			done
			# shellcheck disable=SC2086
			set -- $newlist
		fi
		# Log pruning decision (once)
		if [ "$CFG_DEBUG" = "1" ]; then
			logger -t "${NAME}" -p daemon.debug "TXT pruning applied: final_count=$_tok_count cap=$TXT_CAP args=$(printf '%s ' "$@")"
		fi
	fi
	# ---------------------------------------------------------------------------

	# Write deterministic ordinal map and placeholder overlay tokens (if overlay enabled)
	mkdir -p /tmp/nrsyncd_state 2>/dev/null || true
	ordinal_file="/tmp/nrsyncd_state/ordinal_map"
	{
		umask 077
		: >"${ordinal_file}.tmp"
		for p in $ordinal_map_pairs; do
			[ -z "$p" ] && continue
			on=${p%%:*}
			ofc=${p#*:}
			[ -n "$on" ] && [ -n "$ofc" ] && printf '%s %s\n' "$on" "$ofc" >>"${ordinal_file}.tmp"
		done
		mv "${ordinal_file}.tmp" "$ordinal_file" 2>/dev/null || true
	} 2>/dev/null
	overlay_tokens="/tmp/nrsyncd_overlay_tokens"
	base_tokens="/tmp/nrsyncd_state/base_txt"
	if [ "$CFG_ACTIVITY_OVERLAY" = "1" ]; then
		umask 077
		if [ ! -f "$overlay_tokens" ]; then
			{
				echo 'a=<none>'
				echo 'i=<none>'
			} >"${overlay_tokens}.tmp" 2>/dev/null && mv "${overlay_tokens}.tmp" "$overlay_tokens" 2>/dev/null || true
		fi
		# Sanitize any malformed overlay tokens created by external tools: split literal "\n" into
		# real newlines, strip CRs, and ensure we have distinct a=/i= lines. Keep content minimal
		# to avoid operator surprises; only fix obvious shape issues.
		if [ -f "$overlay_tokens" ]; then
			_sanit_tmp="${overlay_tokens}.sanit"
			# 1) Replace literal backslash-n with real newline; 2) drop CR; 3) collapse empty lines
			awk '{ line=$0; gsub(/\\n/,"\n",line); print line }' "$overlay_tokens" |
				tr -d '\r' |
				awk 'NF{print}' >"$_sanit_tmp" 2>/dev/null || true
			# Ensure the presence of a=/i= lines; if missing, append stubs (empty values)
			if ! grep -q '^a=' "$_sanit_tmp" 2>/dev/null; then echo 'a=' >>"$_sanit_tmp"; fi
			if ! grep -q '^i=' "$_sanit_tmp" 2>/dev/null; then echo 'i=' >>"$_sanit_tmp"; fi
			mv -f "$_sanit_tmp" "$overlay_tokens" 2>/dev/null || true
			# If operator provided a static i-list via UCI, set it now (keep a= empty)
			if [ -n "$CFG_OVERLAY_I_STATIC" ]; then
				{
					echo 'a='
					printf 'i=%s\n' "$CFG_OVERLAY_I_STATIC"
				} >"${overlay_tokens}.tmp" 2>/dev/null && mv "${overlay_tokens}.tmp" "$overlay_tokens" 2>/dev/null || true
			fi
		fi
		# Write base tokens (all TXT args including placeholders) for sidecar merge
		{
			umask 077
			: >"${base_tokens}.tmp"
			for _tkn in "$@"; do
				[ -n "$_tkn" ] && printf '%s\n' "$_tkn" >>"${base_tokens}.tmp"
			done
			mv "${base_tokens}.tmp" "$base_tokens" 2>/dev/null || true
		} 2>/dev/null
	fi

	# Post-deprecation (after legacy removal window) we warn if only the fallback browse record would be discoverable.
	# If umdns is available we attempt a quick browse for the versioned service; if absent but legacy is present, warn.
	if command -v ubus >/dev/null 2>&1; then
		# Use jsonfilter defensively only if present.
		if command -v jsonfilter >/dev/null 2>&1; then
			# Defensive parser: some jsonfilter variants/mocks can emit TXT arrays split elements.
			# We only need counts here; if parsing fails treat as zero to avoid hard-fail.
			primary_count=$(ubus call umdns browse 2>/dev/null | jsonfilter -l1 -e '@["_nrsyncd_v1._udp"] | length(@)' 2>/dev/null || echo 0)
			legacy_count=$(ubus call umdns browse 2>/dev/null | jsonfilter -l1 -e '@["_rrm_nr._udp"] | length(@)' 2>/dev/null || echo 0)
			# Warn only if legacy exists but primary absent.
			if [ "${primary_count:-0}" = "0" ] && [ "${legacy_count:-0}" != "0" ]; then
				logger -t "${NAME}" -p daemon.warning "Only legacy browse record (_rrm_nr._udp) discovered; primary _nrsyncd_v1._udp absent. Check service advertisement or upgrade peers."
			fi
		fi
	fi

	procd_open_instance
	# Ensure runtime/cache directory skeleton exists so daemon can write early
	mkdir -p /tmp/nrsyncd_state/group_cache 2>/dev/null || true
	procd_set_param term_timeout 5
	procd_set_param env \
		NRSYNCD_UPDATE_INTERVAL="$NRSYNCD_UPDATE_INTERVAL" \
		NRSYNCD_JITTER_MAX="$NRSYNCD_JITTER_MAX" \
		NRSYNCD_DEBUG="$NRSYNCD_DEBUG" \
		NRSYNCD_UMDNS_REFRESH_INTERVAL="$NRSYNCD_UMDNS_REFRESH_INTERVAL" \
		NRSYNCD_UMDNS_SETTLE_DELAY="$NRSYNCD_UMDNS_SETTLE_DELAY" \
		NRSYNCD_ACTIVITY_OVERLAY="$NRSYNCD_ACTIVITY_OVERLAY" \
		NRSYNCD_ORDINAL_MAP="$ordinal_file" \
		NRSYNCD_SKIP_IFACES="$skip_ifaces" \
		NRSYNCD_QUICK_MAX_MS="$QUICK_MAX_MS" \
		NRSYNCD_SECOND_PASS_MS="$SECOND_PASS_MS" \
		RRM_NR_UPDATE_INTERVAL="$RRM_NR_UPDATE_INTERVAL" \
		RRM_NR_JITTER_MAX="$RRM_NR_JITTER_MAX" \
		RRM_NR_DEBUG="$RRM_NR_DEBUG" \
		RRM_NR_UMDNS_REFRESH_INTERVAL="$RRM_NR_UMDNS_REFRESH_INTERVAL" \
		RRM_NR_UMDNS_SETTLE_DELAY="$RRM_NR_UMDNS_SETTLE_DELAY" \
		RRM_NR_ACTIVITY_OVERLAY="$RRM_NR_ACTIVITY_OVERLAY" \
		RRM_NR_ORDINAL_MAP="$ordinal_file" \
		RRM_NR_SKIP_IFACES="$skip_ifaces" \
		RRM_NR_QUICK_MAX_MS="$QUICK_MAX_MS" \
		RRM_NR_SECOND_PASS_MS="$SECOND_PASS_MS"
	# Launch daemon with assembled SSIDn= arguments so it can build neighbor reports
	procd_set_param command /usr/bin/nrsyncd "$@"
	# Advertise versioned service type (maps to _nrsyncd_v1._udp) on dedicated port 32025 (moved from 5247 to avoid CAPWAP IANA port). Daemon additionally browses _rrm_nr._udp for interoperability
	procd_add_mdns "nrsyncd_v1" "udp" "32025" "$@"
	procd_close_instance

	# Internal publisher removed.

	# Optional sidechannel listener (prototype). Default disabled.
	if [ "$CFG_SIDECHANNEL_ENABLE" = "1" ]; then
		sc_bin="/usr/bin/nrsyncd_sidechannel"
		if [ -x "$sc_bin" ]; then
			procd_open_instance nrsyncd_sc
			procd_set_param term_timeout 5
			procd_set_param respawn 1 5 5
			procd_set_param env \
				NRSYNCD_SC_PROTO="$CFG_SIDECHANNEL_PROTO" \
				NRSYNCD_SC_PORT="$CFG_SIDECHANNEL_PORT" \
				NRSYNCD_SC_PSK="$CFG_SIDECHANNEL_PSK" \
				NRSYNCD_SC_BIND="$CFG_SIDECHANNEL_BIND" \
				NRSYNCD_SC_DEBUG="$CFG_DEBUG" \
				NRSYNCD_SC_STATE_DIR="/tmp/nrsyncd_state"
			procd_set_param command "$sc_bin"
			procd_close_instance
		else
			logger -t "${NAME}" -p daemon.info "sidechannel_enable=1 but $sc_bin not found; skipping sidechannel"
		fi
	fi

	# Optional broadcast helper: proactively send heartbeats/status to peers via sc=
	if [ "$CFG_SIDECHANNEL_BCAST_ENABLE" = "1" ]; then
		bh_bin="/usr/bin/nrsyncd_broadcast_helper"
		if [ -x "$bh_bin" ]; then
			procd_open_instance nrsyncd_sc_bcast
			procd_set_param term_timeout 5
			procd_set_param respawn 1 5 5
			procd_set_param env \
				NRSYNCD_SC_DEBUG="$CFG_DEBUG" \
				NRSYNCD_SC_STATE_DIR="/tmp/nrsyncd_state" \
				NRSYNCD_SC_PSK="$CFG_SIDECHANNEL_PSK" \
				NRSYNCD_SC_PROTO="$CFG_SIDECHANNEL_PROTO" \
				NRSYNCD_SC_BCAST_INTERVAL="$CFG_SIDECHANNEL_BCAST_INTERVAL" \
				NRSYNCD_SC_BCAST_JITTER="$CFG_SIDECHANNEL_BCAST_JITTER"
			procd_set_param command "$bh_bin"
			procd_close_instance
		else
			logger -t "${NAME}" -p daemon.info "sidechannel_broadcast_enable=1 but $bh_bin not found; skipping broadcast"
		fi
	fi
	return 0
}

boot() { start; }

# Explicit start wrapper (rc.common sometimes safer with direct start)
start() { start_service; }

# Minimal usage output only when interactive (attached to a TTY) to avoid
# noisy procd syslog lines for internal calls with unknown/implicit actions.
usage() {
	[ -t 1 ] || return 0
	cat >&2 <<'EOU'
Syntax: /etc/init.d/nrsyncd [command]

Available commands:
	start           Start the service
	stop            Stop the service
	restart         Restart the service
	reload          Reload configuration (SIGHUP daemon; no full restart)
	enable          Enable service autostart
	disable         Disable service autostart
	enabled         Check if service is started on boot
	running         Check if service is running
	status          Show runtime state + metrics summary
	mapping         Show iface/BSSID/channel/freq/width/center1/SSID mapping (live)
	mapping_json    Show mapping as JSON array (alias: mapping-json)
	neighbors       Dump current neighbor lists (per iface)
	cache           Show cache directory summary
	refresh         Force immediate refresh (SIGUSR1)
	diag            Probe readiness timings (per iface)
	metrics         Show metrics counters (if present)
	timing_check    Alias of diag (timing-check also accepted)
	version         Show init script version + git hash (if available)
	skiplist        Show configured skip_iface entries (effective)
	help            This help

Notes:
	- timing_check / timing-check are interchangeable.
	- skiplist reflects current UCI (list skip_iface ...) after normalization.
EOU
}
help() { usage; }
print_usage() { usage; }

# Optional invocation trace (set NRSYNCD_LOG_INVOCATION=1 before calling to enable)
[ "${NRSYNCD_LOG_INVOCATION:-0}" = "1" ] && logger -t "${NAME}" -p daemon.debug "invoked: $0 $* (argc=$#)"

service_triggers() {
	procd_add_reload_trigger "network" "wireless"
}

# Expose a user-invoked reload that sends SIGHUP to the running daemon so it
# can rebuild interface mapping and skip list without full restart.
reload_service() {
	# Send SIGHUP to daemon to trigger its internal re-load
	procd_send_signal nrsyncd 1 2>/dev/null || {
		logger -t "${NAME}" -p daemon.warning "Reload requested but daemon not running"
		return 1
	}
	load_nrsyncd_config
	class_line=$(rrm_nr_classify_ifaces "$CFG_SKIP_IFACES")
	ready_count=0 cfg_skipped="" not_ready=""
	# shellcheck disable=SC2086
	eval "$class_line"
	# cfg_skipped / not_ready / ready_count now set
	# Count words in not_ready (empty -> 0)
	# Intentional word splitting (space-delimited lists from classify helper)
	# shellcheck disable=SC2086
	if [ -n "$not_ready" ]; then
		set -- $not_ready
		not_ready_count=$#
	else not_ready_count=0; fi
	# shellcheck disable=SC2086
	if [ -n "$cfg_skipped" ]; then
		set -- $cfg_skipped
		cfg_skipped_count=$#
	else cfg_skipped_count=0; fi
	if [ $cfg_skipped_count -eq 0 ] && [ $not_ready_count -eq 0 ]; then
		logger -t "${NAME}" -p daemon.info "Reload assembled $ready_count SSID entries (no skips)"
	else
		logger -t "${NAME}" -p daemon.info "Reload assembled $ready_count SSID entries (config-skipped $cfg_skipped_count, not-ready $not_ready_count)"
	fi
	[ -n "$CFG_SKIP_IFACES" ] && logger -t "${NAME}" -p daemon.info "Skip list: $CFG_SKIP_IFACES"

	# Reload-time warning for unmatched skip entries
	if [ -n "$CFG_SKIP_IFACES" ]; then
		all_ifaces=$(ubus list hostapd.* 2>/dev/null | sed 's/^hostapd.//')
		unmatched=""
		for s in $CFG_SKIP_IFACES; do
			found=0
			for h in $all_ifaces; do [ "$s" = "$h" ] && found=1 && break; done
			[ $found -eq 0 ] && unmatched="$unmatched $s"
		done
		[ -n "$unmatched" ] && logger -t "${NAME}" -p daemon.warning "Configured skip_iface entries not present: $(echo "$unmatched" | sed 's/^ *//')"
	fi
}

status_service() {
	state_file="/tmp/nrsyncd_runtime"
	metrics_file="/tmp/nrsyncd_metrics"
	if [ -f "$state_file" ]; then
		printf 'nrsyncd status:\n'
		sed 's/^/  /' "$state_file"
		# Include currently configured skip list from UCI for clarity
		load_nrsyncd_config
		[ -n "$CFG_SKIP_IFACES" ] && printf '  configured_skip: %s\n' "$CFG_SKIP_IFACES"
		[ -f "$metrics_file" ] && {
			printf '  metrics:\n'
			sed 's/^/    /' "$metrics_file"
		}
	else
		echo "nrsyncd status: runtime state not yet written (daemon starting?)"
	fi
}

# Print iface->SSID mapping (live)
mapping_service() {
	printf '  %-12s %-17s %-4s %-6s %-5s %-6s %s\n' iface bssid chan freq width c1 SSID
	rrm_nr_map_ifaces | sed 's/^/  /'
}
mapping_json_service() { rrm_nr_map_ifaces_json; }

# Dump current neighbor list per interface
neighbors_service() {
	for obj in $(ubus list hostapd.* 2>/dev/null); do
		ifc=${obj#hostapd.}
		printf '%s:\n' "$ifc"
		ubus call "$obj" rrm_nr_list 2>/dev/null | sed 's/^/  /'
	done
}

# Show cache directory overview
cache_service() {
	dir=/tmp/nrsyncd_state/group_cache
	# Defensive: if execution reaches here but nothing is printed later, having this line helps field debugging.
	# (Will be followed by a more specific line below.)
	: # noop for shellcheck; retained comment only
	if [ ! -d "$dir" ]; then
		# Provide contextual pending status if metrics exist
		if [ -f /tmp/nrsyncd_metrics ]; then
			cycle=""
			nr_sets_sent=""
			remote_entries_merged=""
			last_update_time=""
			while IFS='=' read -r k v; do
				case "$k" in
				cycle) cycle=$v ;;
				nr_sets_sent) nr_sets_sent=$v ;;
				remote_entries_merged) remote_entries_merged=$v ;;
				last_update_time) last_update_time=$v ;;
				esac
			done </tmp/nrsyncd_metrics
			[ -z "$cycle" ] && cycle="?"
			[ -z "$nr_sets_sent" ] && nr_sets_sent=0
			[ -z "$remote_entries_merged" ] && remote_entries_merged=0
			[ -z "$last_update_time" ] && last_update_time=0
			echo "cache: pending (no cache directory yet; cycles=$cycle nr_sets_sent=$nr_sets_sent remote_entries_merged=$remote_entries_merged last_update_time=$last_update_time)"
		else
			echo "cache: pending (no cache directory yet; metrics unavailable)"
		fi
		return
	fi
	# If no .list files yet, avoid silent return (glob stays literal when unmatched)
	set -- "$dir"/*.list
	if [ "$1" = "$dir/*.list" ]; then
		echo "cache: empty (directory present; no neighbor list files yet)"
		return
	fi
	for f in "$dir"/*.list; do
		[ -f "$f" ] || continue
		h=$(basename "$f")
		sz=$(wc -c <"$f" 2>/dev/null)
		mt=$(date -r "$f" +%s 2>/dev/null || stat -c %Y "$f" 2>/dev/null)
		head=$(head -c 60 "$f" 2>/dev/null)
		printf '%s size=%s mtime=%s sample=%s\n' "$h" "$sz" "$mt" "$head"
	done
}

# Force immediate refresh via SIGUSR1
refresh_service() {
	# First try via procd (quiet); fallback to direct kill if instance not registered.
	if procd_send_signal nrsyncd 10 2>/dev/null; then
		return 0
	fi
	# Fallback: find running daemon shell wrapper
	pid=$(pgrep -f '/usr/bin/nrsyncd' 2>/dev/null | head -n1)
	if [ -n "$pid" ]; then
		kill -USR1 "$pid" 2>/dev/null && echo 'refresh: sent USR1 (direct)'
		return 0
	fi
	echo 'refresh: daemon not running' >&2
	return 1
}

# One-shot readiness diagnostic (adaptive retries summary)
diag_service() { for obj in $(ubus list hostapd.* 2>/dev/null); do rrm_nr_probe_iface "${obj#hostapd.}"; done; }

metrics_service() { [ -f /tmp/nrsyncd_metrics ] && cat /tmp/nrsyncd_metrics || echo 'metrics: unavailable'; }

timing_check_service() { for obj in $(ubus list hostapd.* 2>/dev/null); do rrm_nr_probe_iface "${obj#hostapd.}"; done; }

version_service() {
	printf 'nrsyncd init version=%s' "$NRSYNCD_INIT_VERSION"
	githash=$(git -C /etc/rc.d rev-parse --short HEAD 2>/dev/null || true)
	[ -n "$githash" ] && printf ' git=%s' "$githash"
	printf '\n'
}

extra_command() {
	case "$1" in mapping | mapping_json | mapping-json | neighbors | cache | refresh | diag | metrics | timing-check | timing_check | version | status | skiplist | summary | reset_metrics | metadata | overlay | overlay_state) return 0 ;; esac
	return 1
}
mapping() { mapping_service; }
mapping_json() { mapping_json_service; }
neighbors() { neighbors_service; }
cache() { cache_service; }
refresh() { refresh_service; }
diag() { diag_service; }
metrics() { metrics_service; }
timing_check() { timing_check_service; }
version() { version_service; }
metadata() { metadata_service; }
overlay_service() {
	ordinal_file="/tmp/nrsyncd_state/ordinal_map"
	tokens_file="/tmp/nrsyncd_overlay_tokens"
	if [ -f "$ordinal_file" ]; then
		echo "overlay: ordinal_map ($ordinal_file)"
		sed 's/^/  /' "$ordinal_file"
	else
		echo "overlay: ordinal_map missing ($ordinal_file)"
	fi
	if [ -f "$tokens_file" ]; then
		echo "overlay: tokens ($tokens_file)"
		sed 's/^/  /' "$tokens_file"
	else
		echo "overlay: tokens missing ($tokens_file)"
	fi
}
overlay() { overlay_service; }
overlay_state() { overlay_service; }
status() { status_service; }
skiplist_service() {
	load_nrsyncd_config
	if [ -n "$CFG_SKIP_IFACES" ]; then printf '%s\n' "$CFG_SKIP_IFACES"; else echo 'none'; fi
}
skiplist() { skiplist_service; }

# Concise metrics summary with derived ratios
summary_service() {
	metrics_file="/tmp/nrsyncd_metrics"
	[ ! -f "$metrics_file" ] && {
		echo 'summary: metrics unavailable'
		return 1
	}
	# Read metrics into variables
	while IFS='=' read -r k v; do
		case "$k" in
		cycle) cycle=$v ;;
		nr_sets_sent) nr_sets_sent=$v ;;
		nr_sets_suppressed) nr_sets_suppressed=$v ;;
		cache_hits) cache_hits=$v ;;
		cache_misses) cache_misses=$v ;;
		remote_entries_merged) remote_entries_merged=$v ;;
		remote_unique_cycle) remote_unique_cycle=$v ;;
		remote_unique_total) remote_unique_total=$v ;;
		baseline_ssids) baseline_ssids=$v ;;
		suppression_ratio_pct) suppression_ratio_pct=$v ;;
		last_update_time) last_update_time=$v ;;
		nr_set_failures) nr_set_failures=$v ;;
		neighbor_count_*) neighbor_counts="$neighbor_counts $k=$v" ;;
		esac
	done <"$metrics_file"
	[ -z "$nr_sets_sent" ] && nr_sets_sent=0
	[ -z "$nr_sets_suppressed" ] && nr_sets_suppressed=0
	[ -z "$suppression_ratio_pct" ] && suppression_ratio_pct=0
	# Derive neighbor count stats (min/max/ifaces) for quick glance
	min_nc=""
	max_nc=""
	min_list=""
	max_list=""
	total_nc=0
	nc_ifaces=0
	for pair in $neighbor_counts; do
		iface=${pair%%=*}
		cnt=${pair#*=}
		# iface variable includes prefix 'neighbor_count_'
		iface_short=${iface#neighbor_count_}
		[ -z "$cnt" ] && continue
		case "$cnt" in '' | *[!0-9]*) continue ;; esac
		total_nc=$((total_nc + cnt))
		nc_ifaces=$((nc_ifaces + 1))
		if [ -z "$min_nc" ] || [ "$cnt" -lt "$min_nc" ]; then
			min_nc=$cnt
			min_list=$iface_short
		elif [ "$cnt" -eq "$min_nc" ]; then min_list="$min_list,$iface_short"; fi
		if [ -z "$max_nc" ] || [ "$cnt" -gt "$max_nc" ]; then
			max_nc=$cnt
			max_list=$iface_short
		elif [ "$cnt" -eq "$max_nc" ]; then max_list="$max_list,$iface_short"; fi
	done
	[ -n "$nc_ifaces" ] && [ "$nc_ifaces" -gt 0 ] && avg_nc=$((total_nc / nc_ifaces)) || avg_nc=0
	printf 'summary: cycles=%s pushes=%s suppressed=%s suppression=%s%% cache(hit/miss)=%s/%s baseline_ssids=%s remote(entries=%s uniq_cycle=%s uniq_total=%s) failures=%s neigh(min=%s@%s max=%s@%s avg=%s ifaces=%s) last_update=%s\n' \
		"${cycle:-?}" "$nr_sets_sent" "$nr_sets_suppressed" "$suppression_ratio_pct" \
		"${cache_hits:-0}" "${cache_misses:-0}" "${baseline_ssids:-0}" \
		"${remote_entries_merged:-0}" "${remote_unique_cycle:-0}" "${remote_unique_total:-0}" "${nr_set_failures:-0}" \
		"${min_nc:-0}" "${min_list:-none}" "${max_nc:-0}" "${max_list:-none}" "$avg_nc" "$nc_ifaces" "${last_update_time:-0}"
}
summary() { summary_service; }
reset_metrics_service() {
	# Try procd signal first (USR2 = 12)
	if procd_send_signal nrsyncd 12 2>/dev/null; then
		return 0
	fi
	pid=$(pgrep -f '/usr/bin/nrsyncd' 2>/dev/null | head -n1)
	[ -n "$pid" ] && {
		kill -USR2 "$pid" 2>/dev/null && echo 'reset_metrics: sent USR2 (direct)'
		return 0
	}
	echo 'reset_metrics: daemon not running' >&2
	return 1
}
reset_metrics() { reset_metrics_service; }

# Parse currently advertised SSIDn= TXT entries + metadata (v/c/h) from a live browse.
# Outputs lines: count=<int> hash=<8hex|na> version=<int> ssids=<n> sample="SSID1=... SSID2=... ..." raw_args=<total_tokens>
metadata_service() {
	if ! command -v ubus >/dev/null 2>&1 || ! command -v jsonfilter >/dev/null 2>&1; then
		echo 'metadata: requires ubus + jsonfilter'
		return 1
	fi

	# Helper: try to extract TXT items for a given selector; prints items one per line
	extract_txt() {
		sel="$1"
		src="$2" # sel: jsonfilter selector, src: announcements|browse
		case "$src" in
		announcements) ubus call umdns announcements 2>/dev/null | jsonfilter -e "$sel" 2>/dev/null ;;
		browse) ubus call umdns browse 2>/dev/null | jsonfilter -e "$sel" 2>/dev/null ;;
		esac
	}

	# Try in this order:
	# 1) announcements for versioned key (.local suffix)
	# 2) browse for versioned key (no suffix)
	# 3) announcements for legacy key
	# 4) browse for legacy key
	txt_lines=$(extract_txt "@['_nrsyncd_v1._udp.local'][*].txt[*]" announcements)
	[ -z "$txt_lines" ] && txt_lines=$(extract_txt "@['_nrsyncd_v1._udp'][*].txt[*]" browse)
	[ -z "$txt_lines" ] && txt_lines=$(extract_txt "@['_rrm_nr._udp.local'][*].txt[*]" announcements)
	[ -z "$txt_lines" ] && txt_lines=$(extract_txt "@['_rrm_nr._udp'][*].txt[*]" browse)

	if [ -z "$txt_lines" ]; then
		# Attempt raw fallback: scan raw browse JSON for quoted SSIDn=/v=/c=/h= tokens.
		# This handles cases where jsonfilter selector syntax diverges across versions or
		# mocks produce slightly different shapes.
		raw_json=$(ubus call umdns browse 2>/dev/null || true)
		if [ -n "$raw_json" ]; then
			# Extract tokens inside quotes beginning with SSIDn= or metadata keys.
			# Use awk to avoid excessive grep/sed pipelines; strip trailing punctuation.
			txt_lines=$(printf '%s' "$raw_json" | awk 'match($0, /"SSID[0-9]+=[^"]+"/){ print substr($0, RSTART+1, RLENGTH-2) } match($0, /"v=1"/){ print "v=1" } match($0, /"c=[0-9]+"/){ m=substr($0, RSTART+1, RLENGTH-2); print m } match($0, /"h=[0-9a-fA-F]+"/){ m=substr($0, RSTART+1, RLENGTH-2); print m }')
		fi
		if [ -z "$txt_lines" ]; then
			echo 'metadata: no TXT entries found'
			return 1
		fi
	fi

	ssid_count=0
	total=0
	sample=""
	sample_limit=4
	meta_v=""
	meta_c=""
	meta_h=""
	sample_added=0
	# Read each TXT item as a full line to preserve spaces within SSID arrays
	echo "$txt_lines" | while IFS= read -r t; do
		[ -z "$t" ] && continue
		total=$((total + 1))
		case "$t" in
		SSID[0-9]*=*)
			ssid_count=$((ssid_count + 1))
			if [ $sample_added -lt $sample_limit ]; then
				if [ -n "$sample" ]; then sample="$sample $t"; else sample="$t"; fi
				sample_added=$((sample_added + 1))
			fi
			;;
		v=*) meta_v=${t#v=} ;;
		c=*) meta_c=${t#c=} ;;
		h=*) meta_h=${t#h=} ;;
		esac
	done

	# The while in a subshell wonâ€™t update outer vars on some shells; recompute minimally for reporting.
	# Derive version/count/hash from txt_lines again (single-pass awk to avoid subshell var loss)
	report=$(echo "$txt_lines" | awk '
		BEGIN{v="";c="";h="";sc="";ss=0;total=0;sample_count=0;sample_limit=4;sample=""}
		{
			line=$0;
			if(line ~ /^SSID[0-9]+=/){
				ss++;
				if(sample_count<sample_limit){ if(sample!=""){sample=sample" "line}else{sample=line}; sample_count++ }
			} else if(line ~ /^v=/){ sub(/^v=/, "", line); v=line }
			else if(line ~ /^c=/){ sub(/^c=/, "", line); c=line }
			else if(line ~ /^h=/){ sub(/^h=/, "", line); h=line }
			else if(line ~ /^sc=/ && sc==""){ sub(/^sc=/, "", line); sc=line }
			total++
		}
		END{ if(sample=="") sample="none"; printf("%s\n%s\n%s\n%s\n%s\n%s\n", v, c, h, ss, sample, sc) }')
	meta_v=$(echo "$report" | sed -n '1p')
	meta_c=$(echo "$report" | sed -n '2p')
	meta_h=$(echo "$report" | sed -n '3p')
	ssid_count=$(echo "$report" | sed -n '4p')
	sample=$(echo "$report" | sed -n '5p')
	meta_sc=$(echo "$report" | sed -n '6p')
	total=$(echo "$txt_lines" | wc -l | tr -d ' ')

	# Reconcile: if advertised count mismatches parsed SSID count, prefer parsed value for reporting
	# but keep original in a warning to stderr for operator awareness (non-fatal).
	orig_meta_c=$meta_c
	if [ -n "$meta_c" ] && [ -n "$ssid_count" ] && [ "$meta_c" != "$ssid_count" ]; then
		# Emit a concise warning (debug style tag kept consistent)
		logger -t "${NAME}" -p daemon.warning "metadata count mismatch (c=$meta_c parsed=$ssid_count)"
		meta_c=$ssid_count
	fi

	# Ensure basic sanitation: limit sample length to avoid pathological huge output
	# (already capped by sample_limit but double guard for future edits)
	case ${#sample} in
	[0-2][0-9][0-9]) : ;;                               # up to 299 chars fine
	*) sample=$(printf '%s' "$sample" | cut -c1-300) ;; # truncate conservatively
	esac

	# Normalize sc reporting for operator clarity
	[ -z "$meta_sc" ] && meta_sc="<none>"
	printf 'metadata: version=%s count=%s hash=%s ssids=%s sample="%s" raw_tokens=%s sc=%s\n' "${meta_v:-?}" "${meta_c:-?}" "${meta_h:-?}" "${ssid_count:-0}" "$sample" "$total" "$meta_sc"
}
