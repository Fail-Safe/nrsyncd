#!/bin/sh
# Mock ubus supporting minimal subset
CMD=$1
shift
case $CMD in
list)
	# output hostapd.* objects or ignore args
	cat "$SCENARIO/ubus.list" 2>/dev/null
	;;
call)
	OBJ=$1
	METHOD=$2
	shift 2
	case $METHOD in
	rrm_nr_get_own)
		IFACE=${OBJ#hostapd.}
		RAW=$(grep "^$IFACE=" "$SCENARIO/rrm.values" 2>/dev/null | cut -d= -f2-)
		[ -z "$RAW" ] && RAW="NR-$IFACE"
		# Derive SSID same way as bss method for consistency
		SSID=$(grep "^$IFACE " "$SCENARIO/iwinfo.map" 2>/dev/null | cut -d' ' -f2-)
		[ -z "$SSID" ] && SSID=TestSSID
		# Escape SSID for JSON safety
		ESSID=$(printf '%s' "$SSID" | sed 's/\\/\\\\/g; s/"/\\"/g')
		# Deterministic synthetic BSSID based on iface hash
		h=$(printf '%s' "$IFACE" | md5sum 2>/dev/null | awk '{print $1}')
		[ -z "$h" ] && h=$(printf '%s' "$IFACE" | od -An -tx1 | tr -d ' \n')
		# Use first 12 hex chars (6 bytes)
		b1=${h%????????????????????????????}
		b1=$(printf '%s' "$h" | cut -c1-12)
		# Format into MAC (ensure length 12)
		while [ "${#b1}" -lt 12 ]; do b1="${b1}0"; done
		BSSID=$(printf '%s' "$b1" | sed 's/\(..\)/\1:/g; s/:$//')
		HEX="010203" # static minimal hex payload placeholder
		printf '{"value":["%s","%s","%s"]}' "$BSSID" "$ESSID" "$HEX"
		;;
	bss)
		IFACE=${OBJ#hostapd.}
		SSID=$(grep "^$IFACE " "$SCENARIO/iwinfo.map" 2>/dev/null | cut -d' ' -f2-)
		[ -z "$SSID" ] && SSID=TestSSID
		ESSID=$(printf '%s' "$SSID" | sed 's/\\/\\\\/g; s/"/\\"/g')
		printf '{"ssid":"%s"}' "$ESSID"
		;;
	browse)
		if [ "$OBJ" = "umdns" ]; then
			if [ -f "$SCENARIO/umdns.browse" ]; then
				content=$(cat "$SCENARIO/umdns.browse")
				# Detect overlay flag (mock UCI config) only if state file present
				overlay_flag=0
				if [ -n "$STATE_DIR" ] && grep -q '^nrsyncd.global.activity_overlay=1' "$STATE_DIR/uci.conf" 2>/dev/null; then
					overlay_flag=1
				fi
				if [ $overlay_flag -eq 1 ]; then
					# Only mutate if placeholders not already present to remain idempotent.
					echo "$content" | grep -q '"a=<none>"' || {
						content=$(printf '%s' "$content" |
							sed -e 's/"v=1"/"v=2"/' \
								-e 's/"h=\([^"]*\)"/"h=\1","a=<none>","i=<none>"/')
					}
				fi
				printf '%s' "$content"
			fi
		fi
		;;
	announcements)
		if [ "$OBJ" = "umdns" ]; then
			# Simulate announcements having a .local key and the same TXT
			# Transform the browse JSON into announcements shape by adding .local suffix
			# for simplicity we just replace the key string.
			if [ -f "$SCENARIO/umdns.browse" ]; then
				content=$(sed 's/"_nrsyncd_v1._udp"/"_nrsyncd_v1._udp.local"/g; s/"_rrm_nr._udp"/"_rrm_nr._udp.local"/g' "$SCENARIO/umdns.browse")
				# Detect overlay flag (reuse logic for browse path)
				overlay_flag=0
				if [ -n "$STATE_DIR" ] && grep -q '^nrsyncd.global.activity_overlay=1' "$STATE_DIR/uci.conf" 2>/dev/null; then
					overlay_flag=1
				fi
				if [ $overlay_flag -eq 1 ]; then
					echo "$content" | grep -q '"a=<none>"' || {
						content=$(printf '%s' "$content" |
							sed -e 's/"v=1"/"v=2"/' \
								-e 's/"h=\([^"]*\)"/"h=\1","a=<none>","i=<none>"/')
					}
				fi
				printf '%s' "$content"
			fi
		fi
		;;
	rrm_nr_list)
		IFACE=${OBJ#hostapd.}
		if [ -n "$STATE_DIR" ] && [ -f "$STATE_DIR/$IFACE.current" ]; then
			cur=$(cat "$STATE_DIR/$IFACE.current" 2>/dev/null)
			printf '{"list":%s}' "$cur"
		else
			echo '{"list":[]}'
		fi
		;;
	rrm_nr_set)
		IFACE=${OBJ#hostapd.}
		payload="$*"
		# Record set operation for assertions
		if [ -n "$STATE_DIR" ]; then
			[ -d "$STATE_DIR" ] || mkdir -p "$STATE_DIR" 2>/dev/null
			echo "$IFACE $payload" >>"$STATE_DIR/nrsyncd_set.log" 2>/dev/null
			echo "MOCK_UBUS_SET $IFACE $payload" >>"${LOG_FILE:-/tmp/nrsyncd_test.log}" 2>/dev/null
			# Persist new list for subsequent rrm_nr_list calls
			echo "$payload" | sed -n 's/.*"list"[ ]*:[ ]*\(\[.*\]\).*/\1/p' >"$STATE_DIR/$IFACE.current" 2>/dev/null
		fi
		echo "(mock ubus) rrm_nr_set $IFACE" >&2
		echo '{}'
		;;
	update) ;; # ignore explicit 'umdns update'
	esac
	;;
*) ;;
esac
